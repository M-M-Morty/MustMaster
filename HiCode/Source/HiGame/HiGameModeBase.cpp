// Copyright Epic Games, Inc. All Rights Reserved.


#include "HiGameModeBase.h"

#include "Characters/HiPlayerController.h"
#include "NetCommon/DistributedDSConnectionBase.h"
#include "UObject/ConstructorHelpers.h"
#include "GEOSpaceManager.h"
#include "HiLogChannels.h"
#include "HiPlayerState.h"
#include "UnrealGameplayEntityComponent.h"
#include "Characters/HiPlayerController.h"
#include "GameFramework/PlayerState.h"
#include "Kismet/GameplayStatics.h"


AHiGameModeBase::AHiGameModeBase()
{	
}

FString AHiGameModeBase::InitNewPlayer(APlayerController* NewPlayerController, const FUniqueNetIdRepl& UniqueId, const FString& Options, const FString& Portal)
{
	return Super::InitNewPlayer(NewPlayerController, UniqueId, Options, Portal);
}

APlayerController* AHiGameModeBase::Login(UPlayer* NewPlayer, ENetRole InRemoteRole, const FString& Portal, const FString& Options, const FUniqueNetIdRepl& UniqueId, FString& ErrorMessage)
{
	return Super::Login(NewPlayer, InRemoteRole, Portal, Options, UniqueId, ErrorMessage);
}

void AHiGameModeBase::PostLogin(APlayerController* NewPlayer)
{
	Super::PostLogin(NewPlayer);
	if (auto* PC = Cast<AHiPlayerController>(NewPlayer))
	{
		if (auto* SpaceManager = GetWorld()->GetSubsystem<UGeoSpaceManager>())
		{
			TArray<FGeoRegionInfo> RegionInfoList = SpaceManager->GetRegionInfo();
			PC->ClientSetGeoSpaceInfo(SpaceManager->GetWorldConfig(), RegionInfoList);
		}
	}
}

void AHiGameModeBase::ReplicateStreamingStatus(APlayerController* PC)
{
	if (auto* PlayerController = Cast<AHiPlayerController>(PC))
	{
		PlayerController->PlayerReplicateStreamingStatus();
	}
	else
	{
		Super::ReplicateStreamingStatus(PC);
	}
}


bool AHiGameModeBase::EnableCheats_Implementation(APlayerController* P)
{
	return Super::AllowCheats(P); // Always allow cheats in editor (PIE now supports networking)
}

bool AHiGameModeBase::AllowCheats(APlayerController* P)
{
	return EnableCheats(P);
}

APlayerController* AHiGameModeBase::SpawnPlayerController(ENetRole InRemoteRole, const FString& Options)
{
	FLoginProgressScope ProgressScope(this, Options);
	return Super::SpawnPlayerController(InRemoteRole, Options);
}

APlayerController* AHiGameModeBase::SpawnPlayerControllerCommon(ENetRole InRemoteRole, FVector const& SpawnLocation, FRotator const& SpawnRotation, TSubclassOf<APlayerController> InPlayerControllerClass)
{
	FActorSpawnParameters SpawnInfo;
	SpawnInfo.Instigator = GetInstigator();
	SpawnInfo.ObjectFlags |= RF_Transient;	// We never want to save player controllers into a map
	SpawnInfo.bDeferConstruction = true;
	APlayerController* NewPC = GetWorld()->SpawnActor<APlayerController>(InPlayerControllerClass, SpawnLocation, SpawnRotation, SpawnInfo);
	if (NewPC)
	{
		if (InRemoteRole == ROLE_SimulatedProxy)
		{
			// This is a local player because it has no authority/autonomous remote role
			NewPC->SetAsLocalPlayerController();
		}
		
		AHiPlayerController* HiPC = Cast<AHiPlayerController>(NewPC);
		if (HiPC && bInLoginProgressScope)
		{
			// EntityID allocated by LobbyService
			FString PlayerID = UGameplayStatics::ParseOption(LoginProgressOptions, "PlayerID");
			if (!PlayerID.IsEmpty())
			{
				HiPC->InitPlayerProxyID(FCString::Atoi64(*PlayerID));
			}
			// Guid generated by G6
			FString PlayerGuid = UGameplayStatics::ParseOption(LoginProgressOptions, "Guid");
			if (!PlayerGuid.IsEmpty())
			{
				HiPC->InitPlayerGuid(FCString::Atoi64(*PlayerGuid));
			}
			// Guid generated by G6
			FString PlayerRoleId = UGameplayStatics::ParseOption(LoginProgressOptions, "PlayerRoleId");
			if (!PlayerRoleId.IsEmpty())
			{
				HiPC->InitPlayerRoleId(FCString::Atoi64(*PlayerRoleId));
			}
		}

		UGameplayStatics::FinishSpawningActor(NewPC, FTransform(SpawnRotation, SpawnLocation));
	}

	return NewPC;
}

void AHiGameModeBase::Logout(AController* Exiting)
{
	APlayerController* PC = Cast<APlayerController>(Exiting);
	if ( PC != nullptr )
	{
		AddInactivePlayer(PC->PlayerState, PC);
	}

	Super::Logout(Exiting);
}

void AHiGameModeBase::AddInactivePlayer(APlayerState* PlayerState, APlayerController* PC)
{
	AHiPlayerState* HiPlayerState = Cast<AHiPlayerState>(PlayerState);
	if (HiPlayerState == nullptr)
	{
		UE_LOG(LogHiGame, Error, TEXT("AHiGameModeBase::AddInactivePlayer invalid PlayerState: %s"), *PlayerState->GetName());
		return;
	}
	UUnrealGameplayEntityComponent* GameplayEntityComponent = PlayerState->GetComponentByClass<UUnrealGameplayEntityComponent>();
	if (GameplayEntityComponent == nullptr)
	{
		UE_LOG(LogHiGame, Error, TEXT("AHiGameModeBase::AddInactivePlayer PlayerState: %s get UUnrealGameplayEntityComponent nullptr"), *PlayerState->GetName());
		return;
	}
	if (GameplayEntityComponent->IsEntityDestroying())
	{
		UE_LOG(LogHiGame, Log, TEXT("AHiGameModeBase::AddInactivePlayer PlayerState: %s is Destroying"), *PlayerState->GetName());
		return;
	}
	uint64 EntityID = GameplayEntityComponent->GetEntityID();
	InactivePlayers.Emplace(EntityID, HiPlayerState);
	UE_LOG(LogHiGame, Log, TEXT("AHiGameModeBase::AddInactivePlayer PlayerState:%s Entity:%llu Added"), *PlayerState->GetName(), EntityID);
}

void AHiGameModeBase::RemoveInactivePlayer(APlayerState* PlayerState)
{
	UUnrealGameplayEntityComponent* GameplayEntityComponent = PlayerState->GetComponentByClass<UUnrealGameplayEntityComponent>();
	if (GameplayEntityComponent == nullptr)
	{
		UE_LOG(LogHiGame, Error, TEXT("AHiGameModeBase::RemoveInactivePlayer PlayerState: %s get UUnrealGameplayEntityComponent nullptr"), *PlayerState->GetName());
		return;
	}
	uint64 EntityID = GameplayEntityComponent->GetEntityID();
	if (InactivePlayers.Remove(EntityID))
	{
		UE_LOG(LogHiGame, Log, TEXT("AHiGameModeBase::RemoveInactivePlayer PlayerState:%s Entity:%llu Removed"), *PlayerState->GetName(), EntityID);
	}
}

APlayerState* AHiGameModeBase::PopInactivePlayer(uint64 EntityID)
{
	if (InactivePlayers.Contains(EntityID))
	{
		return InactivePlayers.FindAndRemoveChecked(EntityID);
	}
	return nullptr;
}

void AHiGameModeBase::RestartPlayerAtPlayerStart(AController* NewPlayer, AActor* StartSpot)
{
	if (NewPlayer == nullptr || NewPlayer->IsPendingKillPending())
	{
		return;
	}

	if (!StartSpot)
	{
		UE_LOG(LogHiGame, Warning, TEXT("AHiGameModeBase::RestartPlayerAtPlayerStart: Player start not found"));
		return;
	}

	FRotator SpawnRotation = StartSpot->GetActorRotation();

	UE_LOG(LogHiGame, Verbose, TEXT("AHiGameModeBase::RestartPlayerAtPlayerStart %s"), (NewPlayer && NewPlayer->PlayerState) ? *NewPlayer->PlayerState->GetPlayerName() : TEXT("Unknown"));

	if (MustSpectate(Cast<APlayerController>(NewPlayer)))
	{
		UE_LOG(LogHiGame, Verbose, TEXT("AHiGameModeBase::RestartPlayerAtPlayerStart: Tried to restart a spectator-only player!"));
		return;
	}

	if (NewPlayer->GetPawn() != nullptr)
	{
		// If we have an existing pawn, just use it's rotation
		SpawnRotation = NewPlayer->GetPawn()->GetActorRotation();
	}
	else
	{
		AHiPlayerState* HiPlayerState = Cast<AHiPlayerState>(NewPlayer->PlayerState);
		AHiPlayerController* HiPlayerController = Cast<AHiPlayerController>(NewPlayer);
		AHiCharacter* ExistedCharacter = nullptr;
		if (HiPlayerState != nullptr && HiPlayerController != nullptr)
		{
			HiPlayerState->RecoverSwitchPlayersOfPlayerController(HiPlayerController); // todo: remove after switch player data moved to PlayerState
			AHiCharacter* Character = HiPlayerState->GetCurrentSwitchPlayer();
			if (Character != nullptr)
			{
				if (IsValid(Character))
				{
					ExistedCharacter = Character;
					NewPlayer->SetPawn(Character);
				}
				else
				{
					UE_LOG(LogHiGame, Error, TEXT("AHiGameModeBase::RestartPlayerAtPlayerStart: player %s find an invalide character. try create new"), *HiPlayerState->GetPlayerName());
				}
			}
			else
			{
				UE_LOG(LogHiGame, Log, TEXT("AHiGameModeBase::RestartPlayerAtPlayerStart: player %s find no character. try create new"), *HiPlayerState->GetPlayerName());
			}
		}
		else
		{
			UE_LOG(LogHiGame, Error, TEXT("AHiGameModeBase::RestartPlayerAtPlayerStart: player %s is not AHiPlayerState or AHiPlayerController. try create new"), *NewPlayer->GetName());
		}
		if (ExistedCharacter == nullptr)
		{
			if (GetDefaultPawnClassForController(NewPlayer) != nullptr)
			{
				// Try to create a pawn to use of the default class for this player
				APawn* NewPawn = SpawnDefaultPawnFor(NewPlayer, StartSpot);
				if (IsValid(NewPawn))
				{
					NewPlayer->SetPawn(NewPawn);
				}
			}
		}
	}
	
	if (!IsValid(NewPlayer->GetPawn()))
	{
		FailedToRestartPlayer(NewPlayer);
	}
	else
	{
		// Tell the start spot it was used
		InitStartSpot(StartSpot, NewPlayer);

		FinishRestartPlayer(NewPlayer, SpawnRotation);
	}
}




