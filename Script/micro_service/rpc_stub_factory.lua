---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by yongzyzhang.
--- DateTime: 2024/4/17 下午6:24
---
---
---Examples are at the end of the file
---
---Warn 确保UDSRaptorEngineSubsystem::InitializeSDK() 调用完毕后才require 这个模块
---

local IRPC = require("micro_service.irpc.irpc")
local PROTOC = require("micro_service.ProtocInstance")
local IRPCLog = require("micro_service.irpc.irpc_log")
local IRPCCore = require("irpc_core")
local G = require("G")
local MsConfig = require("micro_service.ms_config")


local function AsyncCallback(Context, Response)
    local Status = Context:GetStatus()
    if (not Status:OK()) then
        IRPCLog.LogError(
            "Client AsyncCallback fail, frame: %d, func: %d, msg: %s",
            Status:GetFrameworkRetCode(),
            Status:GetFuncRetCode(),
            Status:ErrorMessage()
        )
        return
    end
    IRPCLog.LogInfo("Client AsyncCallback succ")
end

local function GetCallerName()
    local CallerName = "G6Connector"
    -- no tsf4g service 
    if UE.UHiUtilsFunctionLibrary.IsLocalAdapter() then
        return CallerName
    end
    local bIsDedicatedServer = UE.UHiUtilsFunctionLibrary.IsServerWorld()
    if bIsDedicatedServer then
        CallerName = "G6Connector_DSSDK"
    end
    return CallerName
end

---@class RPCServiceClientStub 无状态服务TSF2G客户端调用桩
local RPCServiceClientStub = Class()

function RPCServiceClientStub:ctor(RPCServiceName)
    local Config = MsConfig.Proto2MicroServiceNameMap[RPCServiceName]
    assert(Config ~= nil, "No RPCService Config Of Name:" .. RPCServiceName)

    self.RPCServiceName = RPCServiceName

    --RPC服务所在的宿主TSF4G服务名
    self.HostTSF4G2ServerName = Config.TSF4G2ServerName
    --是否有状态，有状态服调用需提供一致性的hashkey用于路由
    self.bHostTSF4G2ServerStateful = Config.Stateful

    --加载Proto文件
    PROTOC:loadfile(Config.ProtoFile)

    self.RPCClientStub = nil
    self.AsyncRPCClientStub = nil
end

local function InjectClientContextInfo(ClientContext, RPCServerName, HashKey, PlayerRoleId)
    -- 测试期间设置超时为30秒
    ClientContext:SetTimeout(30 * 1000)

    if UE.UHiUtilsFunctionLibrary.IsServerWorld() then
        --DS 调用TSF4G2微服务需要通过DSA转发
        ClientContext:SetTargetService("DsaService")
        ClientContext:AddReqMeta("g6_forward_service", RPCServerName)
        --local DsSessionId = SubsystemUtils.GetDSRaptorEngineSubsystem():GetDsSessionID()
        --ClientContext:AddReqMeta("g6_ds_game_session_id", DsSessionId)

        -- DS侧 注入role_id
        if PlayerRoleId then
            ClientContext:AddReqMeta("role_id", PlayerRoleId)
        end
        
        -- HashKey路由 DSA 需要g6_forward_hash_key 请求元数据key
        if HashKey and type(HashKey) == "number" and HashKey ~= 0 then
            ClientContext:AddReqMeta("g6_forward_hash_key", tostring(HashKey))
        end
    else
        ClientContext:SetTargetService(RPCServerName)
    end
    
    return ClientContext
end

---AsyncCallRPCFunction 异步调用
---@param FuncName string
---@param FuncRequest table
---@param Callback function
function RPCServiceClientStub:AsyncCallRPCFunction(FuncName, ClientContext, FuncRequest, Callback)
    if self.AsyncRPCClientStub == nil then
        self.AsyncRPCClientStub = IRPC:GetRPCClient(GetCallerName(), self.RPCServiceName)
    end
    Callback = Callback or AsyncCallback
    
    --只输出警告
    self:CheckHashKey(ClientContext)
    local ReqMeta = ClientContext:GetReqMeta()
    local bResult = self.AsyncRPCClientStub[FuncName](self.AsyncRPCClientStub, ClientContext, FuncRequest, Callback)
    if not bResult or not ClientContext:GetStatus():OK() then
        Callback(ClientContext, {})
    end
    return bResult
end

---CallRPCFunction 同步调用，需要保证在协程环境中
---@param FuncName string
---@param FuncRequest table
function RPCServiceClientStub:CallRPCFunction(FuncName, ClientContext, FuncRequest)
    if (not coroutine.isyieldable()) then
        IRPCLog.LogError("Sync CallRPCFunction should call in coroutine")
        return false, nil
    end
    
    if self.RPCClientStub == nil then
        self.RPCClientStub = IRPC:GetRPCClient(GetCallerName(), self.RPCServiceName, "coroutine")
    end
    
    --只输出警告
    self:CheckHashKey(ClientContext)
    
    -- local ClientContext = self:CreateClientContext(HashKey)
    IRPCLog.LogDebugFormat("%s RPC Stub Before CallRPCFunction: %s", self.RPCServiceName, FuncName)
    local bResult, Response = self.RPCClientStub[FuncName](self.RPCClientStub, ClientContext, FuncRequest)
    IRPCLog.LogDebugFormat("%s RPC Stub After CallRPCFunction: %s", self.RPCServiceName, FuncName)

    return ClientContext, Response
end

--检查有状态服，是否有一致性hash路由键
function RPCServiceClientStub:CheckHashKey(ClientContext)
    if self.bHostTSF4G2ServerStateful then
        local HashKey = ClientContext:GetHashKey()
        if HashKey == nil or HashKey == 0 then
            IRPCLog.LogWarnFormat("%s Server is stateful, should cal rpc with hashkey", self.HostTSF4G2ServerName)
        end
    end
end

---@class RPCServiceClientStubHolder
local RPCServiceClientStubHolder = Class()

function RPCServiceClientStubHolder:ctor(Stub)
    self.Stub = Stub
end

function RPCServiceClientStubHolder:BindRouterKey(RouterKey)
    self.RouterKey = RouterKey
end

local CoroPrefix = "Coro_"
local CoroPrefixLength = string.len(CoroPrefix)

RPCServiceClientStubHolder.__index = function(t, k)
    local mt = getmetatable(t)
    local p = mt[k]
    if p ~= nil then
        return p
    else
        local AsyncCallRPCFunction = t.Stub.AsyncCallRPCFunction
        local Coro_CallRPCFunction = t.Stub.CallRPCFunction

        local FuncName = k
        local bCoro = false
        if string.sub(FuncName, 1, CoroPrefixLength) == CoroPrefix then
            bCoro = true
            FuncName = string.sub(FuncName, CoroPrefixLength + 1)
        end
        if bCoro then
            local CoroCall = function(M, ...)
                local ParamCnt = select('#', ...)
                local Request
                local ClientContext = IRPCCore:NewClientContext()
                if ParamCnt == 1 then
                    Request = select(1, ...)
                elseif ParamCnt == 2 then
                    ClientContext, _ = select(1, ...)
                    Request = select(2, ...)
                else
                    IRPCLog.LogError("Param count error")
                end
                InjectClientContextInfo(ClientContext, t.Stub.HostTSF4G2ServerName, t.RouterKey)
                return Coro_CallRPCFunction(t.Stub, FuncName, ClientContext, Request)
            end
            p = CoroCall
        else
            local AsyncCall = function(M, ...)
                local ParamCnt = select('#', ...)
                local Request
                local Callback
                local ClientContext = IRPCCore:NewClientContext()
                if ParamCnt == 1 then
                    Request = select(1, ...)
                elseif ParamCnt == 2 then
                    local Params = { select(1, ...) }
                    if type(Params[#Params]) == "function" then
                        Request, Callback = select(1, ...)
                    else
                        ClientContext, Request = select(1, ...)
                    end
                elseif ParamCnt == 3 then
                    ClientContext, Request, Callback = select(1, ...)
                else
                    IRPCLog.LogError("Param count error")
                end
                InjectClientContextInfo(ClientContext, t.Stub.HostTSF4G2ServerName, t.RouterKey)

                return AsyncCallRPCFunction(t.Stub, FuncName, ClientContext, Request, Callback)
            end
            p = AsyncCall
        end
        rawset(t, k, p)
        return p
    end
end

local RPCStubMap = {}

---@class RPCClientStubFactory
local RPCClientStubFactory = Class()

---GetRPCStub
---@param RPCServiceName string RPCService名，请使用ms_config.lua中配置的lua常量
---@return RPCServiceClientStubHolder
function RPCClientStubFactory:GetRPCStub(RPCServiceName)
    ---@type RPCServiceClientStub
    local Stub = RPCStubMap[RPCServiceName]

    if Stub == nil then
        Stub = RPCServiceClientStub.new(RPCServiceName)
        if RPCStubMap[RPCServiceName] == nil then
            RPCStubMap[RPCServiceName] = Stub
        end
    end

    local StubHolder = { Stub=Stub, RouterKey=0, PlayerRoleId=0 }
    StubHolder.BindPlayerRoleId = function(M, PlayerRoleId)
        rawset(M, "PlayerRoleId", PlayerRoleId)
    end
    
    setmetatable(StubHolder, RPCServiceClientStubHolder)

    return StubHolder
end

function RPCClientStubFactory:TestAsyncRPC()
    local MSConfig = require("micro_service.ms_config")
    local IRPCLog = require("micro_service.irpc.irpc_log")
    if self.OfficeRPCStub == nil then
        self.OfficeRPCStub = self:GetRPCStub(MSConfig.OfficeRPCServiceName)
    end
    local function AsyncCallback(Context, Response)
        local Status = Context:GetStatus()
        if (not Status:OK()) then
            IRPCLog.LogErrorFormat(
                "RPCClientStubFactory TestAsyncRPC fail2, frame: %d, func: %d, msg: %s",
                Status:GetFrameworkRetCode(),
                Status:GetFuncRetCode(),
                Status:ErrorMessage()
            )
            return
        end
        IRPCLog.LogInfo("RPCClientStubFactory TestAsyncRPC async Call succ")
    end
    local HelloRequest = {
        Guid = 10000,
        PlayerID = 20000
    }
    --self.OfficeRPCStub:BindRouterKey(10000)
    self.OfficeRPCStub:Hello(HelloRequest, AsyncCallback)
end

function RPCClientStubFactory:LoadEntityServiceProto(EntityServiceName)
    local file = MsConfig.EntityMeta2ProtoFileMap[EntityServiceName]
    self:LoadProto(file)
end


function RPCClientStubFactory:LoadProto(file)
    PROTOC:loadfile(file)
end

function RPCClientStubFactory:GetCallName()
    return GetCallerName()
end

local Instance = RPCClientStubFactory.new()
return Instance

---example for async RPC call with callback
--function TestAsyncRPC()
--    local MSConfig = require("micro_service.ms_config")
--    local RPCStubFactory = require("micro_service.rpc_stub_factory")
--    local AsyncOfficeRPCStub = RPCStubFactory:GetRPCStub(MSConfig.OfficeRPCServiceName)
--
--    local IRPCLog = require("micro_service.irpc.irpc_log")
--    local function AsyncCallback(Context, Response)
--        local Status = Context:GetStatus()
--        if (not Status:OK()) then
--            IRPCLog.LogError("OfficeComponent async Call Office Hello fail2, frame: %d, func: %d, msg: %s", Status:GetFrameworkRetCode(), Status:GetFuncRetCode(), Status:ErrorMessage())
--            return
--        end
--        IRPCLog.LogInfo("OfficeComponent async Call succ")
--    end
--    local HelloRequest = {
--        Guid = 10000,
--        PlayerID = 20000
--    }
--    local bResult, ClientStatus = AsyncOfficeRPCStub:AsyncCallRPCFunction("Hello", HelloRequest, AsyncCallback, 10000)
--    if not bResult or not ClientStatus:OK() then
--        IRPCLog.LogError("OfficeComponent async Call Office Hello fail1, result: %s, frame: %d, func: %d, msg: %s", bResult, ClientStatus:GetFrameworkRetCode(), ClientStatus:GetFuncRetCode(), ClientStatus:ErrorMessage())
--        return
--    end
--end

---example for sync RPC call

--function TestSyncRPC()
--    local MSConfig = require("micro_service.ms_config")
--    local RPCStubFactory = require("micro_service.rpc_stub_factory")
--    ---@type RPCServiceClientStub
--    local OfficeRPCStub = RPCStubFactory:GetRPCStub(MSConfig.OfficeRPCServiceName)
--
--    local IRPCLog = require("micro_service.irpc.irpc_log")
--
--    local HelloRequest = {
--        Guid = 10001,
--        PlayerID = 20001
--    }
--    local co = coroutine.create(function()
--        local bResult, Response, ClientStatus = OfficeRPCStub:CallRPCFunction("Hello", HelloRequest, 10001)
--        if not bResult or not ClientStatus:OK() then
--            IRPCLog.LogError("OfficeComponent Sync Call Office Hello fail, result: %s, frame: %d, func: %d, msg: %s",
--                    bResult, ClientStatus:GetFrameworkRetCode(), ClientStatus:GetFuncRetCode(), ClientStatus:ErrorMessage())
--            return
--        else
--            IRPCLog.LogInfoFormat("OfficeComponent Sync Call Office Hello Succeed, result: %s", Response.Msg)
--        end
--    end)
--    local result, value = coroutine.resume(co)
--    if (result == false) then
--        IRPCLog.LogError("Lua Error:" .. debug.traceback(co, value))
--    end
--
--end
